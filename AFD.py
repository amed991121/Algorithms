# -*- coding: utf-8 -*-
"""Actividad13.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1p0UWpuyEH7bcX9kC7uP0n7q5_ufeDlI9
"""

import re

class AFD(object):
    """
    Clase que implementa un Autómata Finito Determinista (AFD).
    Un AFD es una máquina de estados que procesa cadenas de símbolos y determina si pertenecen a un lenguaje.
    """
    def __init__(self, sigma=None, states=None, functions=None, initial_state=None, final_states=None):
        """
        Constructor de la clase AFD.
        Parámetros:
        - sigma: alfabeto del autómata
        - states: conjunto de estados
        - functions: funciones de transición
        - initial_state: estado inicial
        - final_states: estados finales
        """
        self._sigma = None          # Alfabeto del autómata
        self._states = None         # Conjunto de estados
        self._functions = None      # Funciones de transición
        self._initial_state = None  # Estado inicial
        self._final_states = None   # Estados finales

        # Inicialización de atributos si se proporcionan valores
        if sigma is not None:
            self.sigma = sigma
        if states is not None:
            self.states = states
        if functions is not None:
            self.functions = functions
        if initial_state is not None:
            self.initial_state = initial_state
        if final_states is not None:
            self.final_states = final_states

    @property
    def sigma(self):
        """Getter para el alfabeto del autómata"""
        return self._sigma

    @sigma.setter
    def sigma(self, sigma):
        """
        Setter para el alfabeto del autómata.
        Valida que sigma sea una lista no vacía de símbolos.
        """
        if sigma is None:
            raise ValueError("El alfabeto (sigma) no puede estar vacío")
        if not isinstance(sigma, list):
            raise ValueError("El alfabeto (sigma) debe ser una lista de símbolos")
        self._sigma = sigma

    @property
    def states(self):
        """Getter para los estados del autómata"""
        return self._states

    @states.setter
    def states(self, states):
        """
        Setter para los estados del autómata.
        Genera estados con nombres q1, q2, ..., qn donde n es el número proporcionado.
        """
        if states is None:
            raise ValueError("Los estados no pueden estar vacíos")
        if isinstance(states, int):
            values = []
            for i in range(states):
                values.append(f"q{i + 1}")
            self._states = values
        else:
            raise ValueError("Los estados deben ser especificados como un número entero")

    @property
    def functions(self):
        """Getter para las funciones de transición"""
        return self._functions

    @functions.setter
    def functions(self, functions):
        """
        Setter para las funciones de transición.
        Procesa las transiciones en formato 'q1,símbolo,q2' y las almacena en un diccionario.
        """
        if functions is None:
            raise ValueError("Las funciones de transición no pueden estar vacías")
        if not isinstance(functions, list):
            raise ValueError("Las funciones deben ser una lista de transiciones con el formato (estado, simbolo, estado)")

        transitions = {}
        for function in functions:
            # Valida el formato de la transición usando expresiones regulares
            match = re.match(r'(q[1-9]+),([{}]),(q[1-9]+)'.format('|'.join(self._sigma)), function)
            if match:
                state1, symbol, state2 = match.groups()
                transitions[(state1, symbol)] = state2
            else:
                raise ValueError(f"Formato inválido de transición: {function}")
        self._functions = transitions

    @property
    def initial_state(self):
        """Getter para el estado inicial"""
        return self._initial_state

    @initial_state.setter
    def initial_state(self, initial_state):
        """
        Setter para el estado inicial.
        Valida que el estado inicial sea un estado válido del autómata.
        """
        if initial_state is None:
            raise ValueError("El estado inicial no puede estar vacío")
        match = re.match(r'q[{}]'.format('|'.join(self._states)), initial_state)
        if match:
            self._initial_state = initial_state
        else:
            raise ValueError("El estado inicial debe ser un estado válido")

    @property
    def final_states(self):
        """Getter para los estados finales"""
        return self._final_states

    @final_states.setter
    def final_states(self, final_states):
        """
        Setter para los estados finales.
        Valida que todos los estados finales sean estados válidos del autómata.
        """
        if final_states is None:
            raise ValueError("Los estados finales no pueden estar vacíos")
        if not isinstance(final_states, str):
            raise ValueError("Los estados finales deben ser una lista de estados")
        final_states = final_states.split(",")
        for state in final_states:
            match = re.match(r'q[{}]'.format('|'.join(self._states)), state)
            if not match:
                raise ValueError("Los estados finales deben ser estados válidos")
        self._final_states = final_states

    def process_string(self, list_string):
        """
        Procesa una cadena de entrada para determinar si es aceptada por el autómata.
        Retorna una lista de "accepted" o "rejected" para cada subcadena procesada.

        Parámetros:
        - list_string: lista de cadenas a procesar, puede contener múltiples subcadenas separadas por comas

        Retorna:
        - Lista con el resultado ("accepted"/"rejected") para cada subcadena
        """
        if list_string is None:
            raise ValueError("La lista de cadenas no puede estar vacía")
        if not isinstance(list_string, list):
            raise ValueError("La lista de cadenas debe ser una lista de cadenas")

        output = []
        for value in list_string:
            current_state = self._initial_state
            for symbol in value:
                if symbol in self._sigma:
                    current_state = self._functions[(current_state, symbol)]
                    if current_state is None:
                        return False
                else:
                    return False
            if current_state in self._final_states:
                output.append("accepted")
            else:
                output.append("rejected")
        return output

def main():
    # Ciclo principal que permite crear múltiples autómatas
    while True:
        # Inicialización de variables
        afd = AFD()                # Crea una nueva instancia del Autómata Finito Determinista
        repeat = True              # Control de ciclos de entrada
        sigma = []                 # Almacena el alfabeto de entrada
        functions = []             # Almacena las funciones de transición

        try:
            # Solicita y valida el alfabeto de entrada
            repeat = True
            print("Introduzca el Alfabeto de entrada\nPresione dos x si desea terminar")
            while repeat:
                value = str(input())
                # Validación de entrada: solo símbolos individuales permitidos
                if len(value) > 1 and value != "xx":
                    print("La entrada debe ser solo un símbolo")
                    continue
                elif value.isspace():
                    print("No se permiten espacios como símbolos")
                    continue
                elif not value or (value == "xx" and not sigma):
                    print("Debe introducir al menos un símbolo")
                elif value == "xx" and sigma:
                    repeat = False
                else:
                    sigma.append(value)
            afd.sigma = sigma      # Asigna el alfabeto al autómata
        except Exception as e:
            print(e)
            continue

        try:
            # Solicita y establece el número de estados del autómata
            states = int(input("Introduzca un numero para indicar la cantidad de estados del automata: "))
            afd.states = states
        except Exception as e:
            print(e)
            continue

        try:
            # Solicita y establece el estado inicial del autómata
            initial_state = str(input("Introduzca el estado inicial (q0): "))
            afd.initial_state = initial_state
        except Exception as e:
            print(e)
            continue

        try:
            # Solicita y establece los estados finales del autómata
            final_states = str(input("Introduzca los estados finales con el formato 'q3,q4': "))
            afd.final_states = final_states
        except Exception as e:
            print(e)
            continue

        try:
            # Solicita y valida las funciones de transición
            repeat = True
            print("Introduzca las funciones de transición con la forma 'estado,simbolo,estado'\nPresione dos x si desea terminar")
            while repeat:
                value = str(input())
                # Validación de entrada para funciones de transición
                if not value or (value == "xx" and not functions):
                    print("Debe introducir al menos un símbolo")
                elif value == "xx" and functions:
                    repeat = False
                else:
                    functions.append(value)
            afd.functions = functions   # Asigna las funciones de transición al autómata
        except Exception as e:
            print(e)
            continue

        try:
            # Procesa las cadenas de entrada y muestra resultados
            repeat = True
            print("Introduzca la lista de cadenas a procesar: ")
            while repeat:
                string = str(input())
                # Procesa cada cadena y muestra el resultado
                print(afd.process_string(string))
                # Pregunta si se desean procesar más cadenas
                keep_running = input("¿Desea añadir otra lista de cadenas? (s/n): ").lower()
                if keep_running != 's':
                    repeat = False
        except Exception as e:
            print(e)
            continue

        # Pregunta si se desea crear otro autómata
        keep_running = input("¿Desea crear otro autómata? (s/n): ").lower()
        if keep_running != 's':
            break

# Punto de entrada del programa
if __name__ == "__main__":
    main()